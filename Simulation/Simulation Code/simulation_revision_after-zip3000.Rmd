---
title: "Simul-Code"
author: "Seo Jae Hyun"
date: '2022-07-07'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(locfit)
library(locpol)
library(pscl)
library(gridExtra)
```

### Basic notation

data : data
forcing variable : x
outcome variable : y
cutoff : value
bandwidth : bw



### Checking data generation

```{r data generation}



logistic = function(x) { exp(x)/(1+exp(x))}

loglinear = function(x) {exp(x)}




```




### Local linear regression case

```{r local linear regression}




### Local linear regression

one_linear_ft_coef_and_var=function(data, value, bw, dire='left'){
  
  if (dire=='left'){
    result=data %>% filter(x<value & x>value-bw)
  }
  else if (dire=='right'){
    result=data %>% filter(x>=value & x<value+bw)
  }
  else {
    result='error : dire must be left or right'
  }
    
  K= dnorm(x=value, mean=result$x, sd=bw)
  data_revision = result %>% mutate(x=x-value)
  est=lm(y~x, data=data_revision)
  
  
  return(list(est$coefficients, vcov(est)))


}


# compute tau_SRD by local linear regression



SRD_lm_coef_var=function(data, value, bw){
  
  
  result_left = one_linear_ft_coef_and_var(data=data, value=value, bw=bw, dire='left')
  result_right = one_linear_ft_coef_and_var(data=data, value=value, bw=bw, dire='right')
  
  
  tauhat=result_right[[1]][1]-result_left[[1]][1]
  
  
  sigma_left=result_left[[2]]
  sigma_right=result_right[[2]]
  
  
  
  nl=sum(data$x<value & data$x>value-bw)
  nr=sum(data$x>value & data$x<value+bw)
  

  asym_var=sigma_left[1, 1]+sigma_right[1, 1]
  
  
  return(c(tauhat, asym_var))

  
}





```


### GLM case


```{r local likelihood with glm}


# local likelihood with glm

one_glm_ft_coef_and_var = function(data, value, bw, dire='left', type){
  
  
  if (dire=='left'){
    result=data %>% filter(x<value & x>value-bw)
  }
  else if (dire=='right'){
    result=data %>% filter(x>=value & x<value+bw)
  }
  else {
    result='error : dire must be left or right'
  }
  
  K= dnorm(x=value, mean=result$x, sd=bw)
  data_revision = result %>% mutate(x=x-value)
  est=glm(y~x, data=data_revision, family = type)
  
  
  return(list(est$coefficients, vcov(est)))
  
  
}



# compute tau_SRD by local likelihood



SRD_glm_coef_var = function(data, value, bw, type){
  
  
  result_left = one_glm_ft_coef_and_var(data=data, value=value, bw=bw, dire='left', type)
  result_right = one_glm_ft_coef_and_var(data=data, value=value, bw=bw, dire='right', type)
  
  if (type == 'poisson'){
    
    mu_left = exp(result_left[[1]][1])
    mu_right = exp(result_right[[1]][1])
    
    tau_hat = mu_right - mu_left
    
    sigma_left = result_left[[2]]
    sigma_right = result_right[[2]]
    
    asym_var = mu_left^2*sigma_left[1, 1] + mu_right^2*sigma_right[1, 1]
    
  }
  
  else if (type == 'binomial'){
    
    mu_left = exp(result_left[[1]][1])/(1+exp(result_left[[1]][1]))
    mu_right = exp(result_right[[1]][1])/(1+exp(result_right[[1]][1]))
    
    tau_hat = mu_right - mu_left
    
    sigma_left =result_left[[2]]
    sigma_right = result_right[[2]]
    
    asym_var = (exp(result_left[[1]][1])/(1+exp(result_left[[1]][1]))^2)^2 * sigma_left[1, 1] + (exp(result_right[[1]][1])/(1+exp(result_right[[1]][1]))^2)^2 * sigma_right[1, 1]
    
  }
  
  else if (type == 'quasipoisson'){
    
    mu_left = exp(result_left[[1]][1])
    mu_right = exp(result_right[[1]][1])
    
    tau_hat = mu_right - mu_left
    
    sigma_left = result_left[[2]]
    sigma_right = result_right[[2]]
    
    asym_var = mu_left^2*sigma_left[1, 1] + mu_right^2*sigma_right[1, 1]
    
  }
  
  
  return(c(tau_hat, asym_var))

}



```



### Zero infaltion case



```{r zero infli}


#logistic, loglinear function

logistic = function(x) { exp(x)/(1+exp(x))}

loglinear = function(x) {exp(x)}



### zeroinfl-function

one_zeroinfl_ft_coef_and_var=function(data, value, bw, dire='left'){
  
  if (dire=='left'){
    result=data %>% filter(x<value & x>value-bw)
  }
  else if (dire=='right'){
    result=data %>% filter(x>=value & x<value+bw)
  }
  else {
    result='error : dire must be left or right'
  }
    
  K= dnorm(x=value, mean=result$x, sd=bw)
  data_revision = result %>% mutate(x=x-value)
  est=zeroinfl(y~x, data=data_revision)
  
  
  return(list(est$coefficients, est$vcov))


}







#logit : alpha, log : beta


# gradient of g(theta) - for delta method

gradient_ft = function(alpha0, beta0){
  
  result = c( exp(beta0)/(1+exp(alpha0)), 0, -exp(alpha0+beta0)/(1+exp(alpha0))^2, 0)
  
  return(as.matrix(result, nrow=4))
  
}



# compute tau_SRD and asymptotic variance by local likelihood


SRD_zeroinfl_coef_var=function(data, value, bw){
  
  
  result_left = one_zeroinfl_ft_coef_and_var(data=data, value=value, bw=bw, dire='left')
  result_right = one_zeroinfl_ft_coef_and_var(data=data, value=value, bw=bw, dire='right')
  
  pi_left = exp(result_left[[1]]$zero[1])/(1+exp(result_left[[1]]$zero[1]))
  lambda_left=exp(result_left[[1]]$count[1])
  
  pi_right = exp(result_right[[1]]$zero[1])/(1+exp(result_right[[1]]$zero[1]))
  lambda_right=exp(result_right[[1]]$count[1])
  
  
  sigma_left=result_left[[2]]
  sigma_right=result_right[[2]]
  grad_left=gradient_ft(alpha0=result_left[[1]]$zero[1], beta0=result_left[[1]]$count[1])
  grad_right=gradient_ft(alpha0=result_right[[1]]$zero[1], beta0=result_right[[1]]$count[1])
  
  
  
  nl=sum(data$x<value & data$x>value-bw)
  nr=sum(data$x>value & data$x<value+bw)
  
  tauhat = (1-pi_right)*lambda_right - (1-pi_left)*lambda_left
  
  asym_var=t(grad_left)%*%sigma_left%*%grad_left +t(grad_right)%*%sigma_right%*%grad_right
  
  
  return(c(tauhat, asym_var))

  
}







```



### Cross validation



```{r cross validation}



### Cross-validation


### Finding quantile

quntilerange=function(data, q,cutoff){
  
  return(c(quantile(data$x[data$x<cutoff], q), quantile(data$x[data$x>=cutoff], 1-q)))
}




### Cross-validation

cv_rd_srd = function(data, cutoff, q, bw, type='ZIP'){
  
  
  cvrange=quntilerange(data=data, q=q, cutoff=cutoff)
  
  
  check_df=data[data$x>=cvrange[1] & data$x<=cvrange[2], ]
  check_x=check_df$x
  
  
  result=NULL
  
  
  if (type=='ZIP'){
    
    for (i in 1:length(check_x)){
      if (check_x[i]<cutoff){
        re = one_zeroinfl_ft_coef_and_var(data=data, value=check_x[i], bw=bw, dire='left')[[1]]
      }
      else if (check_x[i]>=cutoff){
        
        re = one_zeroinfl_ft_coef_and_var(data=data, value=check_x[i], bw=bw, dire='right')[[1]]
      }
      
      pi=exp(re$zero[1])/(1+exp(re$zero[1]))
      lambda=exp(re$count[1])
      
      check_y = check_df[i, 'y']
      
      like = ifelse(check_y==0, log(pi +(1-pi)*exp(-lambda)), log(1-pi) - lambda + check_y*log(lambda))
      
      result=c(result, like)
      
    }
  }
  
  
  else if (type=='linear'){
    
    for (i in 1:length(check_x)){
      
      if (check_x[i]<cutoff){
        
        re=one_linear_ft_coef_and_var(data=data, value=check_x[i], bw=bw, dire='left')[[1]]
      }
      else if (check_x[i]>=cutoff){
        
        
        re=one_linear_ft_coef_and_var(data=data, value=check_x[i], bw=bw, dire='right')[[1]]
      }
      
      mu=re[1]
      result=c(result, mu)
    }
    
    return(list(result, mean((check_df$y-result)^2)))
  }
  
  
  else {
    
    for (i in 1:length(check_x)){
      if (check_x[i]<cutoff){
        re = one_glm_ft_coef_and_var(data=data, value=check_x[i], bw=bw, dire='left', type=type)[[1]]
        
      }
      else{
        
        re = one_glm_ft_coef_and_var(data=data, value=check_x[i], bw=bw, dire='right', type=type)[[1]]
        
      }
      
      check_y = check_df[i, 'y']
      
      if (type =='binomial'){
        
        pi = exp(re[1])/(1+exp(re[1]))
        like = check_y * log(pi/(1-pi)) + log(1-pi)
        
      }
      else{
        
         lambda = exp(re[1])
        like = -lambda + y*log(lambda)
      }
      
      result = c(result, like)
    }
    
    
  }
  
  return(list(result, sum(result)))
  


  

}





```








### Simulation function



```{r simulation}


simulation_ft = function(lambda, pi, cutoff, q, range, n, trial, type='ZIP', truediff){
  
  if (type=='ZIP'){
    

  
  # cross validation
  

  
    #tau estimation with replacement
  
    srd_est=NULL
    srd_var=NULL
    srd_lm_est=NULL
    srd_lm_var=NULL  

  
    for (i in 1:trial){
      
      #data generateion
      
      
      x=runif(n, range[1], range[2])
      lamb=lambda(x)
      p=pi(x)
    
      z=rbernoulli(n, p=p)
      zpoi=rpois(n, lambda=lamb)
    
      y=(1-z)*zpoi
      data=data.frame(y=y, x=x)
      
      bandwidth=c(0.01, 0.05, seq(0.1, 3, by=0.1))
      cv_result_lm=NULL
      cv_result_zip=NULL
    
       # cross validation
      
      
      for (j in 1:length(bandwidth)){
      
        result_bd_zip=tryCatch(cv_rd_srd(data=data, cutoff=cutoff, q=q, bw=bandwidth[j], type='ZIP')[[2]], error=function(x) return(-Inf))
        result_bd_lm=tryCatch(cv_rd_srd(data=data, cutoff=cutoff, q=q, bw=bandwidth[j], type='linear')[[2]], error=function(x) return(Inf))
        if (is.nan(result_bd_zip)){
          result_bd_zip = -Inf
        }
        cv_result_zip=c(cv_result_zip, result_bd_zip)
        cv_result_lm=c(cv_result_lm, result_bd_lm)
        print('working')
        print(result_bd_zip)
        print(result_bd_lm)
        print('working')

      
      
      }
      
      print(paste0('Trial ', i, ' is finished.'))
      
      bd_zip=bandwidth[which.max(cv_result_zip)]
      bd_lm=bandwidth[which.min(cv_result_lm)]
      
      
    
    
      result_zip=tryCatch(SRD_zeroinfl_coef_var(data=data, value=cutoff, bw=bd_zip), warning=function(x) return(c(Inf, Inf)), error=function(x) return(c(Inf, Inf)))
    
      result_lm=tryCatch(SRD_lm_coef_var(data, value=cutoff, bw=bd_lm), warning=function(x) return(c(Inf, Inf)), error=function(x) return(c(Inf, Inf)))
    
      srd_est[i]=result_zip[1]
      srd_var[i]=result_zip[2]
      srd_lm_est[i]=result_lm[1]
      srd_lm_var[i]=result_lm[2]

    }
  
  
    final_result=data.frame('zipest'=srd_est, 'zipvar'=srd_var, 'linest'=srd_lm_est, 'linvar'=srd_lm_var) %>% filter(zipest!=Inf, linest!=Inf)
    final_result=final_result %>% mutate(zip_ci_left=zipest-qnorm(0.975, 0, 1)*sqrt(zipvar),
                                       zip_ci_right=zipest+qnorm(0.975, 0, 1)*sqrt(zipvar),
                                       lin_ci_left=linest-qnorm(0.975, 0, 1)*sqrt(linvar),
                                       lin_ci_right=linest+qnorm(0.975, 0, 1)*sqrt(linvar))
  
    final_result=final_result %>% mutate(zip_ci_in=(zip_ci_left < truediff & truediff<zip_ci_right),
                                       lin_ci_in=(lin_ci_left < truediff & truediff<lin_ci_right))
  
    
    
    
    }
  
  else if (type =='poisson' | type== 'quasipoisson'){
    
    
       # data generation
  
    x=runif(n, range[1], range[2])
  
    lamb=lambda(x)
    
  
    zpoi=rpois(n, lambda=lamb)
  
    y=zpoi
  
    data = data.frame(y=y, x=x)
  
  
    # cross validation
  
  
    #tau estimation with replacement
  
    srd_est=NULL
    srd_var=NULL
    srd_lm_est=NULL
    srd_lm_var=NULL  

  
    for (i in 1:trial){
      
    
    
      x=runif(n, range[1], range[2])
      lamb=lambda(x)

      zpoi=rpois(n, lambda=lamb)
    
      y=zpoi
      data=data.frame(y=y, x=x)
    
      
      
      bandwidth=c(0.01, 0.05, seq(0.1, 2, by=0.1))
      cv_result_lm=NULL
      cv_result_poi=NULL
    
    
      for (j in 1:length(bandwidth)){
      
        result_bd_poi=tryCatch(cv_rd_srd(data=data, cutoff=cutoff, q=q, bw=bandwidth[j], type=type)[[2]], error=function(x) return(-Inf))
        result_bd_lm=tryCatch(cv_rd_srd(data=data, cutoff=cutoff, q=q, bw=bandwidth[j], type='linear')[[2]], error=function(x) return(Inf))
        if (is.nan(result_bd_poi)){
          result_bd_poi = -Inf
        }
        cv_result_poi=c(cv_result_poi, result_bd_poi)
        cv_result_lm=c(cv_result_lm, result_bd_lm)
        print('working')
        print(result_bd_poi)
        print(result_bd_lm)
        print('working')

      
      
      }
      
      print(paste0('Trial ', i, ' is finished.'))
      
      bd_zip=bandwidth[which.max(cv_result_poi)]
      bd_lm=bandwidth[which.min(cv_result_lm)]
      
    
      
      
      result_zip=tryCatch(SRD_glm_coef_var(data=data, value=cutoff, bw=bd_zip, type='poisson'), warning=function(x) return(c(Inf, Inf)), error=function(x) return(c(Inf, Inf)))
    
      result_lm=tryCatch(SRD_lm_coef_var(data, value=cutoff, bw=bd_lm), warning=function(x) return(c(Inf, Inf)), error=function(x) return(c(Inf, Inf)))
    
      srd_est[i]=result_zip[1]
      srd_var[i]=result_zip[2]
      srd_lm_est[i]=result_lm[1]
      srd_lm_var[i]=result_lm[2]


      
    
    }
    
    
    final_result=data.frame('zipest'=srd_est, 'zipvar'=srd_var, 'linest'=srd_lm_est, 'linvar'=srd_lm_var) %>% filter(zipest!=Inf, linest!=Inf)
    final_result=final_result %>% mutate(zip_ci_left=zipest-qnorm(0.975, 0, 1)*sqrt(zipvar),
                                       zip_ci_right=zipest+qnorm(0.975, 0, 1)*sqrt(zipvar),
                                       lin_ci_left=linest-qnorm(0.975, 0, 1)*sqrt(linvar),
                                       lin_ci_right=linest+qnorm(0.975, 0, 1)*sqrt(linvar))
  
    final_result=final_result %>% mutate(zip_ci_in=(zip_ci_left < truediff & truediff<zip_ci_right),
                                       lin_ci_in=(lin_ci_left < truediff & truediff<lin_ci_right))

    
    
    
    
    
  }
  
    
  else if(type=='binomial'){
    
    x=runif(n, range[1], range[2])
    
    prob = pi(x)
    
    z = rbernoulli(n, p=prob)
    data = data.frame(x=x, y=z)
    
    
    srd_est=NULL
    srd_var=NULL
    srd_lm_est=NULL
    srd_lm_var=NULL  
    
    for (i in 1:trial){
      
      
      
      x=runif(n, range[1], range[2])
      prob = pi(x)
      
      z = rbernoulli(n, p=prob)
      data = data.frame(x=x, y=z)
      
      
      bandwidth=c(0.01, 0.05, seq(0.1, 2, by=0.1))
      cv_result_lm=NULL
      cv_result_bin=NULL
      
      
      for (j in 1:length(bandwidth)){
      
        result_bd_bin=tryCatch(cv_rd_srd(data=data, cutoff=cutoff, q=q, bw=bandwidth[j], type=type)[[2]], error=function(x) return(-Inf))
        result_bd_lm=tryCatch(cv_rd_srd(data=data, cutoff=cutoff, q=q, bw=bandwidth[j], type='linear')[[2]], error=function(x) return(Inf))
        if (is.nan(result_bd_bin)){
          result_bd_bin = -Inf
        }
        cv_result_bin=c(cv_result_bin, result_bd_bin)
        cv_result_lm=c(cv_result_lm, result_bd_lm)
        print('working')
        print(result_bd_bin)
        print(result_bd_lm)
        print('working')

      
      }
      print(paste0('Trial ', i, ' is finished.'))
      bd_bin=bandwidth[which.max(cv_result_bin)]
      bd_lm=bandwidth[which.min(cv_result_lm)]

      result_bin=tryCatch(SRD_glm_coef_var(data=data, value=cutoff, bw=bd_bin, type='binomial'), warning=function(x) return(c(Inf, Inf)), error=function(x) return(c(Inf, Inf)))
      result_lm=tryCatch(SRD_lm_coef_var(data, value=cutoff, bw=bd_lm), warning=function(x) return(c(Inf, Inf)), error=function(x) return(c(Inf, Inf)))
    
      srd_est[i]=result_bin[1]
      srd_var[i]=result_bin[2]
      srd_lm_est[i]=result_lm[1]
      srd_lm_var[i]=result_lm[2]


        
      
      
      
    }

    
    final_result=data.frame('zipest'=srd_est, 'zipvar'=srd_var, 'linest'=srd_lm_est, 'linvar'=srd_lm_var) %>% filter(zipest!=Inf, linest!=Inf)
    final_result=final_result %>% mutate(zip_ci_left=zipest-qnorm(0.975, 0, 1)*sqrt(zipvar),
                                       zip_ci_right=zipest+qnorm(0.975, 0, 1)*sqrt(zipvar),
                                       lin_ci_left=linest-qnorm(0.975, 0, 1)*sqrt(linvar),
                                       lin_ci_right=linest+qnorm(0.975, 0, 1)*sqrt(linvar))
  
    final_result=final_result %>% mutate(zip_ci_in=(zip_ci_left < truediff & truediff<zip_ci_right),
                                       lin_ci_in=(lin_ci_left < truediff & truediff<lin_ci_right))
    
    
    
  
    
    
    
    
  }
  
  
  

  
  
  

  
  return(final_result)
  
}








```





```{r making csv file, warning=FALSE}


make_csv = function(lambda, pi, cutoff, q, range, n_case, trial, type='ZIP', truediff){
  
  
  
  for (i in 1:length(n_case)){
    
    name = paste0(n_case[i], '_', 'type','_', type, '_', 'trial','_',trial, '.csv')
    
    result = simulation_ft(lambda, pi, cutoff, q, range, n_case[i], trial, type, truediff)
    
    write.csv(result, name)
  }
  
}



```



```{r binomial case, warning=FALSE}


lambdaft=function(x) {return(loglinear(-0.4*x+1.1 + (x>=0)*1.2+4*x*(x>=0)))}
pift = function(x) {return(logistic(0.3*x+1.5-(x>=0)*1.8))}


truediff_zip = exp(2.3)/(1+exp(-0.3)) - exp(1.1)/(1+exp(1.5))
truediff_binomial =  exp(-0.3)/(1+exp(-0.3)) - exp(1.5)/(1+exp(1.5))
truediff_poi = exp(2.3) - exp(1.1)


make_csv(lambda = lambdaft, pi = pift, cutoff =0, q=0.5, range=c(-3, 3), n_case=3000, trial = 250, type='ZIP', truediff = truediff_zip)



```
